package me.dessie.dessielib.enchantmentapi.properties;

import me.dessie.dessielib.enchantmentapi.CEnchantment;

import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

/**
 * Used to define the enchantment properties for obtaining a specific enchantment
 * Properties are used for Enchanting Table, Anvil and Enchantment Book purposes.
 */
public class CEnchantProperties {

    private CEnchantment enchantment;

    //For Enchantment Table enchantability purposes.
    //See https://minecraft.fandom.com/wiki/Enchanting/Levels for vanilla powers.
    //This stores information for choosing this enchantment with a specific level.
    //If the enchantment power falls between the key of the level in min and max, it's a possible enchantment.

    //For example...
    /*
    minModifiedPower = {1=5, 2=10, 3=21}
    maxModifiedPower = {1=12, 2=23, 3=43}
    Chosen Power by calculation = 22
    This enchantment is chosen and would enchant at level 3, since it falls between 21 and 43.
    Though it also falls between 10 and 23, we always use the higher level.
     */
    private Map<Integer, Integer> minModifiedPower = new HashMap<>();
    private Map<Integer, Integer> maxModifiedPower = new HashMap<>();

    //Default Rarities that can be used.
    //If a level is found within the minModifiedPower or maxModifiedPower, that is used before the default.
    //This can just be used for a template.
    private Rarity enchantmentRarity = null;

    //The weight of the enchantment, the higher, the more likely it is to appear
    //when enchanting.
    private int enchantmentWeight = 0;

    //The enchantment cost when combining this enchantment using an anvil.
    //This multiplier is used as (multiplier * newLevel)
    //For example, Looting's multiplier is 4, so if we combine a Looting 3 and Looting 1 sword
    //this would cost 12 levels (4 * 3).

    //More information on anvil costs can be found here
    //https://minecraft.fandom.com/wiki/Anvil_mechanics#Costs_for_combining_enchantments
    private int anvilMultiplier = 0;

    //If true, the enchantment can be picked as a bonus enchantment
    //when enchanting with the enchantment table.
    private boolean canEnchantWithTable = false;

    //If true, the enchantment can be put on a book, and the enchantment table
    //can put this enchantment on books.
    private boolean canBeOnBook = false;

    //If true, the enchantment can be removed using the grindstone.
    private boolean canRemoveWithGrindstone = false;

    //If true, the enchantment can be in villager trades.
    private boolean canBeVillagerTrade = false;

    //The function for determining XP drop, for vanilla me.dessie.dessielib.enchantments, this range is between the min and max modified power.
    //For example, Protection I has a range of 1 to 12. That means we'll get anywhere from 1 to 12 exp when grinding it.
    //If no function is set here, this will be assumed true for this enchantment as well.
    private Function<Integer, Integer> grindstoneXp;

    //If the Grindstone XP dropped should be randomized using Minecraft's logic.
    //if this is false, whatever value is generated by getGrindstoneXP() will ALWAYS be dropped.
    private boolean doGrindstoneXpRandom = false;

    //If this Enchantment should have it's Lore displayed.
    private boolean isLoreDisplayed = false;

    public CEnchantment getEnchantment() { return enchantment; }
    public boolean canRemoveWithGrindstone() { return canRemoveWithGrindstone; }
    public boolean canEnchantWithTable() { return canEnchantWithTable; }
    public boolean canBeOnBook() { return canBeOnBook; }
    public boolean canBeVillagerTrade() { return canBeVillagerTrade; }
    public int getAnvilMultiplier() { return anvilMultiplier; }
    public Rarity getEnchantmentRarity() { return enchantmentRarity; }
    public boolean isDoGrindstoneXpRandom() { return doGrindstoneXpRandom; }
    public boolean isLoreDisplayed() { return isLoreDisplayed; }

    public int getEnchantmentWeight() {
        if(this.enchantmentWeight == 0 && this.getEnchantmentRarity() == null) return 0;
        return this.enchantmentWeight != 0 ? this.enchantmentWeight : this.getEnchantmentRarity().getWeight();
    }

    public int getMinModifiedPower(int level) {
        if(!minModifiedPower.containsKey(level) && this.getEnchantmentRarity() == null) return 0;
        return minModifiedPower.containsKey(level) ? minModifiedPower.get(level) : this.getEnchantmentRarity().getMinPower(level);
    }

    public int getMaxModifiedPower(int level) {
        if(!maxModifiedPower.containsKey(level) && this.getEnchantmentRarity() == null) return 0;
        return maxModifiedPower.containsKey(level) ? maxModifiedPower.get(level) : this.getEnchantmentRarity().getMaxPower(level);
    }

    public int getGrindstoneXp(int level) {
        int baseXp = 0;
        if(this.grindstoneXp != null) {
            return this.grindstoneXp.apply(level);
        } else {
            baseXp += this.getMinModifiedPower(level);
        }

        return baseXp;
    }

    public CEnchantProperties setDoGrindstoneXpRandom(boolean doGrindstoneXpRandom) {
        this.doGrindstoneXpRandom = doGrindstoneXpRandom;
        return this;
    }

    public CEnchantProperties setGrindstoneXpFunction(Function<Integer, Integer> function) {
        this.grindstoneXp = function;
        return this;
    }

    public CEnchantProperties setAsNormalCurse() {
        this.canBeOnBook = true;
        this.canEnchantWithTable = false;
        this.canRemoveWithGrindstone = false;
        this.canBeVillagerTrade = true;
        this.isLoreDisplayed = true;
        return this;
    }

    public CEnchantProperties setAsNormalEnchant() {
        this.enchantmentRarity = Rarity.COMMON;
        this.canBeOnBook = true;
        this.canEnchantWithTable = true;
        this.anvilMultiplier = 1;
        this.canRemoveWithGrindstone = true;
        this.doGrindstoneXpRandom = true;
        this.canBeVillagerTrade = true;
        this.isLoreDisplayed = true;
        return this;
    }

    public CEnchantProperties setEnchantmentRarity(Rarity enchantmentRarity) {
        this.enchantmentRarity = enchantmentRarity;
        return this;
    }

    public CEnchantProperties setEnchantmentWeight(int weight) {
        this.enchantmentWeight = weight;
        return this;
    }

    public CEnchantProperties setLevelPower(int level, int minPower, int maxPower) {
        this.minModifiedPower.put(level, minPower);
        this.maxModifiedPower.put(level, maxPower);
        return this;
    }

    public CEnchantProperties setCanBeOnBook(boolean canBeOnBook) {
        this.canBeOnBook = canBeOnBook;
        return this;
    }

    public CEnchantProperties setCanBeVillagerTrade(boolean canBeVillagerTrade) {
        this.canBeVillagerTrade = canBeVillagerTrade;
        return this;
    }

    public CEnchantProperties setDisplaysLore(boolean displaysLore) {
        this.isLoreDisplayed = displaysLore;
        return this;
    }

    public CEnchantProperties setAnvilMultiplier(int multiplier) {
        this.anvilMultiplier = multiplier;
        return this;
    }

    public CEnchantProperties setCanEnchantWithTable(boolean canEnchantWithTable) {
        this.canEnchantWithTable = canEnchantWithTable;
        return this;
    }

    public CEnchantProperties setCanRemoveWithGrindstone(boolean canRemoveWithGrindstone) {
        this.canRemoveWithGrindstone = canRemoveWithGrindstone;
        return this;
    }

    public CEnchantProperties setEnchantment(CEnchantment enchantment) {
        this.enchantment = enchantment;
        return this;
    }
}
